'use strict';

///////////////////////////////////////
// Modal window

const modal = document.querySelector('.modal');
const overlay = document.querySelector('.overlay');
const btnCloseModal = document.querySelector('.btn--close-modal');
const btnsOpenModal = document.querySelectorAll('.btn--show-modal');

const openModal = function () {
    modal.classList.remove('hidden');
    overlay.classList.remove('hidden');
};

const closeModal = function () {
    modal.classList.add('hidden');
    overlay.classList.add('hidden');
};

for (let i = 0; i < btnsOpenModal.length; i++)
    btnsOpenModal[i].addEventListener('click', openModal);

btnCloseModal.addEventListener('click', closeModal);
overlay.addEventListener('click', closeModal);

document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
        closeModal();
    }
});

//------------------------------------------------------------------------------
// Lecture 200: Implementing Smooth Scrolling
//------------------------------------------------------------------------------
const btnScrollTo = document.querySelector(".btn--scroll-to");
const section1 = document.querySelector("#section--1");


btnScrollTo.addEventListener("click", function (event) {
    // Element.getBoundingClientRect() returns a DOMRect with the size of the viewing rectangle.  For
    // example, the 'x' attribute represents the number of pixels from the LEFT of the page, while the
    // 'y' attribute represents the number of pixels from the TOP of the page.  The 'top' attribute is
    // the same as 'y', while the 'left' attribute is the same as 'x'.
    
    // Basically, getBoundingClientRect() is relative to the visible viewport
    // (As in the part of the page that can be seen).
    const s1coords = section1.getBoundingClientRect();

    // Here's another example by grabbing the button.
    console.log(event.target.getBoundingClientRect());
    
    // We can grab the current scroll position via the `window.scrollX` and `window.scrollY`
    // properties. In other words, the `window.scrollX` attribute is the distance between the left
    // of the page, while the `window.scrollY` attribute is the difference from the top of the page.
    console.log("Current Scroll (X/Y)", window.scrollX, window.scrollY);

    // You can also grab the width and height of the viewport via `document.documentElement.clientHeight`
    // and `document.documentElement.clientWidth`.
    let documentElement = document.documentElement;
    console.log("height/width viewport", documentElement.clientHeight, documentElement.clientWidth);

    // Now, to implement scrolling we do the following:
    // window.scrollTo(s1coords.left, s1coords.top);
    // However, this causes problems since it's relative to the viewpoint - The scroll height will vary depending on your location in the page.

    // In order to fix this, we'll have to take the current scroll position in account:
    // window.scrollTo(s1coords.left + window.scrollX, s1coords.top + window.scrollY);
    
    // However, the scrolling isn't smooth. In order to implement smooth scrolling, place the left
    // and top parameters into its own object property and then set the `behavior` property to
    // "smooth".
    
    // NOTE: This is the old school way of doing this:
    // window.scrollTo({
    //     left: s1coords.left + window.scrollX,
    //     top: s1coords.top + window.scrollY,
    //     behavior: "smooth"
    // });

    
    // The new way of doing this is like so - This is only supported on browsers from 2020 on-wards:
    section1.scrollIntoView({
        behavior: "smooth"
    });
});

//------------------------------------------------------------------------------
// Lecture 201: Types of Events and Event Handlers:
//------------------------------------------------------------------------------

// As before, an event is a signal generated by a DOM node in which something has happened on a
// page.  These events can be handled via Element.addEventListener.  For this example, we'll
// look at the `mouseenter` event:

// const h1 = document.querySelector("h1");
// h1.addEventListener("mouseenter", function(event) {
//     // The mouseenter event is similar to the hover property:
//     window.alert("addEventListener: Great! You are reading the heading. :)");
// });

// You can also attach an event via the Element.onEvent property.
// However, this is considered old school since Element.addEventListener allows us to add multiple functions using the same event.
// h1.onmouseenter = function(event) {
//     // The mouseenter event is similar to the hover property:
//     window.alert("addEventListener: Great! You are reading the heading :)");
// };


// const alertH1 = function(event) {
//     alert("addEventListener: Great! You're reading the heading :)");
// }

// h1.addEventListener("mouseenter", alertH1); 
// We can remove an event via Element.removeEventListener, but we have to store the function first:
// h1.removeEventListener("mouseenter", alertH1);

// Here's a setTimeout version of the same thing:
// setTimeout(() => h1.removeEventListener("mouseenter", alertH1), 3000);
// Finally, there's another way to set an event using an HTML Attribute by defining it directory into the html
// // THIS SHOULDN'T BE USED EVER THOUGH.
// <h1 onclick="alert('Hello World!')"></h1>

/*
 * -----------------------------------------------------------------------------
 * Created by Ulysses Carlos on 01/02/2026 at 07:47 PM
 *
 * Lecture203.script.js
 * Event Propagation in Practice
 * -----------------------------------------------------------------------------
 */

const randomInt = (min, max) => Math.floor(min + (max - min + 1) * Math.random());
const randomColor = () => `rgb(${randomInt(0, 255)}, ${randomInt(0, 255)}, ${randomInt(0, 255)})`;

console.log(randomColor());
document.querySelector(".nav__link").addEventListener("click", function(event) {
    this.style.backGroundColor = randomColor();
    console.log("LINK", event.target, event.currentTarget);
    // e.currentTarget is the same as the `this` keyword:
    console.log(event.currentTarget === this);

    // As before, you can stop an event from bubbling to the parent elements via Event.stopPropagation.
    // This is usually not a good idea though, but can fix complex problems with multiple event listeners.
    event.stopPropagation();
});

document.querySelector(".nav__links").addEventListener("click", function(event) {
    this.style.backGroundColor = randomColor();
    console.log("LINKS", event.target, event.currentTarget);
});

document.querySelector(".nav").addEventListener("click", function(event) {
    this.style.backGroundColor = randomColor();
    console.log("NAV", event.target, event.currentTarget);
});

// In all three handlers, the target is the same due to event bubbling.

// If you want to listen to events in the "Capturing" phase (This is usually irrelevant to us), you can do so
// via the addEventListener with a third parameter. This will cause the event to look at the "Capturing" phase
// instead of the bubbling phase.
// document.querySelector(".nav").addEventListener("click", function(event) {}, true);

/*
 * -----------------------------------------------------------------------------
 * Created by Ulysses Carlos on 01/11/2026 at 09:31 PM
 *
 * Lecture204.script.js
 * Event Delegation
 * -----------------------------------------------------------------------------
 */

"use strict";

// There's not a lot of code in this video, so the main point of it is to describe Event Delegation.

// As per the video, Event Delegation is a way to handle an child element's event in a parent element
// so that you only define a single listener that can handle each of the various child elements.

// For example, if I have an div element foo with child elements bar that handle some form of link,
// instead of assigning event listeners for each of the child elements, I can simply just define a
// single event listener on the parent and then use event.target to determine which child element
// caused the event to fire.

// That way, you can specify the behavior for the various type of child elements.

// The video outlines the following:
// 1. Add event listener to common parent element.
// 2. Determine what element originated the event.

document.querySelector(".nav__links").addEventListener("click", function(event) {
    event.preventDefault();
    // Matching strategy
    // Coming up with a matching strategy is probably the most difficult thing to do at this point, but it's worth it.
    if (event.target.classList.contains("nav__link")) {
        const id = event.target.getAttribute("href");
        console.log(id);
        document.querySelector(id).scrollIntoView({behavior: "smooth"});
        console.log("LINK");
    }
});

/*
 * -----------------------------------------------------------------------------
 * Created by Ulysses Carlos on 01/11/2026 at 09:45 PM
 *
 * Lecture205.script.js
 * DOM Traversing
 * -----------------------------------------------------------------------------
 */

"use strict";

const h1 = document.querySelector("h1");

// Going downwards to access child elements:
console.log(h1.querySelectorAll(".highlight"));
console.log(h1.childNodes);
console.log(h1.children);

// Like you would expect: This refers to the first child element
h1.firstElementChild.style.color = "white";
h1.lastElementChild.style.color = "orangered";

// Going upwards to the parent element
console.log(h1.parentNode);
console.log(h1.parentElement);

// If we want to a find a parent element no matter how far away it is from the DOM tree,
// use Element.closest():
h1.closest(".header").style.background = 'var(--gradient-secondary)'; // Example of applying a CSS variable

// This is the oppsoite of Element.querySelector in which the former finds child elements while Element.closest finds parent elements.
h1.closest(".h1").style.background = 'var(--gradient-primary)';

// Going sideways to find sibling elements.
// We can only access direct siblings via Element.previousElementSibling and Element.nextElementSibling
console.log(h1.previousElementSibling);
console.log(h1.nextElementSibling);

// As before we have the same properties for Nodes:
console.log(h1.previousSibling);
console.log(h1.nextSibling);

// We can always try to access the parent element to find additional children (siblings in this case)
console.log(h1.parentElement.children);

// HTMLCollections are iterable, and so can be used with the spread operator:
[...h1.parentElement.children].forEach(function(element) {
    if (element !== h1)
        element.style.transform = 'scale(0.5)';
});
