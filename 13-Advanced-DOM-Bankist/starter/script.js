'use strict';

///////////////////////////////////////
// Modal window

const modal = document.querySelector('.modal');
const overlay = document.querySelector('.overlay');
const btnCloseModal = document.querySelector('.btn--close-modal');
const btnsOpenModal = document.querySelectorAll('.btn--show-modal');

const openModal = function () {
    modal.classList.remove('hidden');
    overlay.classList.remove('hidden');
};

const closeModal = function () {
    modal.classList.add('hidden');
    overlay.classList.add('hidden');
};

for (let i = 0; i < btnsOpenModal.length; i++)
    btnsOpenModal[i].addEventListener('click', openModal);

btnCloseModal.addEventListener('click', closeModal);
overlay.addEventListener('click', closeModal);

document.addEventListener('keydown', function (e) {
    if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
        closeModal();
    }
});

//------------------------------------------------------------------------------
// Lecture 200: Implementing Smooth Scrolling
//------------------------------------------------------------------------------
const btnScrollTo = document.querySelector(".btn--scroll-to");
const section1 = document.querySelector("#section--1");


btnScrollTo.addEventListener("click", function (event) {
    // Element.getBoundingClientRect() returns a DOMRect with the size of the viewing rectangle.  For
    // example, the 'x' attribute represents the number of pixels from the LEFT of the page, while the
    // 'y' attribute represents the number of pixels from the TOP of the page.  The 'top' attribute is
    // the same as 'y', while the 'left' attribute is the same as 'x'.
    
    // Basically, getBoundingClientRect() is relative to the visible viewport
    // (As in the part of the page that can be seen).
    const s1coords = section1.getBoundingClientRect();

    // Here's another example by grabbing the button.
    console.log(event.target.getBoundingClientRect());
    
    // We can grab the current scroll position via the `window.scrollX` and `window.scrollY`
    // properties. In other words, the `window.scrollX` attribute is the distance between the left
    // of the page, while the `window.scrollY` attribute is the difference from the top of the page.
    console.log("Current Scroll (X/Y)", window.scrollX, window.scrollY);

    // You can also grab the width and height of the viewport via `document.documentElement.clientHeight`
    // and `document.documentElement.clientWidth`.
    let documentElement = document.documentElement;
    console.log("height/width viewport", documentElement.clientHeight, documentElement.clientWidth);

    // Now, to implement scrolling we do the following:
    // window.scrollTo(s1coords.left, s1coords.top);
    // However, this causes problems since it's relative to the viewpoint - The scroll height will vary depending on your location in the page.

    // In order to fix this, we'll have to take the current scroll position in account:
    // window.scrollTo(s1coords.left + window.scrollX, s1coords.top + window.scrollY);
    
    // However, the scrolling isn't smooth. In order to implement smooth scrolling, place the left
    // and top parameters into its own object property and then set the `behavior` property to
    // "smooth".
    
    // NOTE: This is the old school way of doing this:
    // window.scrollTo({
    //     left: s1coords.left + window.scrollX,
    //     top: s1coords.top + window.scrollY,
    //     behavior: "smooth"
    // });

    
    // The new way of doing this is like so - This is only supported on browsers from 2020 on-wards:
    section1.scrollIntoView({
        behavior: "smooth"
    });
});

//------------------------------------------------------------------------------
// Lecture 201: Types of Events and Event Handlers:
//------------------------------------------------------------------------------

// As before, an event is a signal generated by a DOM node in which something has happened on a
// page.  These events can be handled via Element.addEventListener.  For this example, we'll
// look at the `mouseenter` event:

// const h1 = document.querySelector("h1");
// h1.addEventListener("mouseenter", function(event) {
//     // The mouseenter event is similar to the hover property:
//     window.alert("addEventListener: Great! You are reading the heading. :)");
// });

// You can also attach an event via the Element.onEvent property.
// However, this is considered old school since Element.addEventListener allows us to add multiple functions using the same event.
// h1.onmouseenter = function(event) {
//     // The mouseenter event is similar to the hover property:
//     window.alert("addEventListener: Great! You are reading the heading :)");
// };


// const alertH1 = function(event) {
//     alert("addEventListener: Great! You're reading the heading :)");
// }

// h1.addEventListener("mouseenter", alertH1); 
// We can remove an event via Element.removeEventListener, but we have to store the function first:
// h1.removeEventListener("mouseenter", alertH1);

// Here's a setTimeout version of the same thing:
// setTimeout(() => h1.removeEventListener("mouseenter", alertH1), 3000);
// Finally, there's another way to set an event using an HTML Attribute by defining it directory into the html
// // THIS SHOULDN'T BE USED EVER THOUGH.
// <h1 onclick="alert('Hello World!')"></h1>

/*
 * -----------------------------------------------------------------------------
 * Created by Ulysses Carlos on 01/02/2026 at 07:47 PM
 *
 * Lecture203.script.js
 * Event Propagation in Practice
 * -----------------------------------------------------------------------------
 */

const randomInt = (min, max) => Math.floor(min + (max - min + 1) * Math.random());
const randomColor = () => `rgb(${randomInt(0, 255)}, ${randomInt(0, 255)}, ${randomInt(0, 255)})`;

console.log(randomColor());
document.querySelector(".nav__link").addEventListener("click", function(event) {
    this.style.backGroundColor = randomColor();
    console.log("LINK", event.target, event.currentTarget);
    // e.currentTarget is the same as the `this` keyword:
    console.log(event.currentTarget === this);

    // As before, you can stop an event from bubbling to the parent elements via Event.stopPropagation.
    // This is usually not a good idea though, but can fix complex problems with multiple event listeners.
    event.stopPropagation();
});

document.querySelector(".nav__links").addEventListener("click", function(event) {
    this.style.backGroundColor = randomColor();
    console.log("LINKS", event.target, event.currentTarget);
});

document.querySelector(".nav").addEventListener("click", function(event) {
    this.style.backGroundColor = randomColor();
    console.log("NAV", event.target, event.currentTarget);
});

// In all three handlers, the target is the same due to event bubbling.

// If you want to listen to events in the "Capturing" phase (This is usually irrelevant to us), you can do so
// via the addEventListener with a third parameter. This will cause the event to look at the "Capturing" phase
// instead of the bubbling phase.
// document.querySelector(".nav").addEventListener("click", function(event) {}, true);